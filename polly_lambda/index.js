'use strict';

const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

const polly = new AWS.Polly();
const s3 = new AWS.S3();

const AUDIO_BUCKET = process.env.AUDIO_BUCKET; // set via SAM template

const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Content-Type,Authorization',
  'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
};

function jsonResponse(statusCode, body) {
  return {
    statusCode,
    headers: Object.assign({ 'Content-Type': 'application/json' }, CORS_HEADERS),
    body: JSON.stringify(body)
  };
}

exports.handler = async (event) => {
  try {
    // Handle OPTIONS preflight
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers: CORS_HEADERS,
        body: ''
      };
    }

    // GET /task/{taskId}
    if (event.httpMethod === 'GET') {
      const taskId = event.pathParameters && event.pathParameters.taskId;
      if (!taskId) {
        return jsonResponse(400, { error: 'taskId path parameter required' });
      }
      return jsonResponse(501, { message: 'Task status not implemented for synchronous synthesize. Use POST /synthesize.' });
    }

    // POST /synthesize
    if (event.httpMethod === 'POST') {
      if (!event.body) {
        return jsonResponse(400, { error: 'Request body required' });
      }

      let body;
      try {
        body = JSON.parse(event.body);
      } catch (err) {
        return jsonResponse(400, { error: 'Invalid JSON body' });
      }

      const text = (body.text || '').trim();
      const voice = body.voice || 'Joanna';
      const format = (body.format || 'mp3').toLowerCase();

      if (!text) {
        return jsonResponse(400, { error: 'text is required' });
      }
      if (text.length > 3000) {
        return jsonResponse(400, { error: 'text too long; limit to 3000 characters' });
      }
      if (!AUDIO_BUCKET) {
        return jsonResponse(500, { error: 'AUDIO_BUCKET is not configured in environment' });
      }

      const supported = ['mp3', 'ogg_vorbis', 'pcm'];
      if (!supported.includes(format)) {
        return jsonResponse(400, { error: `Unsupported format. Supported: ${supported.join(', ')}` });
      }

      // synthesize
      const pollyParams = {
        Text: text,
        OutputFormat: format === 'mp3' ? 'mp3' : format,
        VoiceId: voice
      };

      const pollyResp = await polly.synthesizeSpeech(pollyParams).promise();
      if (!pollyResp || !pollyResp.AudioStream) {
        return jsonResponse(500, { error: 'No audio generated by Polly' });
      }

      // unique S3 key
      const key = `audio/${uuidv4()}.${format === 'ogg_vorbis' ? 'ogg' : (format === 'pcm' ? 'pcm' : 'mp3')}`;

      // upload to S3
      await s3.upload({
        Bucket: AUDIO_BUCKET,
        Key: key,
        Body: pollyResp.AudioStream,
        ContentType: format === 'mp3' ? 'audio/mpeg' : (format === 'ogg_vorbis' ? 'audio/ogg' : 'audio/wave')
      }).promise();

      // signed URL
      const audioUrl = s3.getSignedUrl('getObject', {
        Bucket: AUDIO_BUCKET,
        Key: key,
        Expires: 300
      });

      return jsonResponse(200, {
        message: 'Synthesis successful',
        s3Key: key,
        audioUrl   // âœ… renamed for frontend compatibility
      });
    }

    return jsonResponse(405, { error: 'Method Not Allowed' });

  } catch (err) {
    console.error('Handler error:', err);
    return jsonResponse(500, { error: 'Internal server error', details: err.message });
  }
};
